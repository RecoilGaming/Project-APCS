# DEVELOPMENT JOURNAL
## P5 Phadke Sharvil

Worked on engine prior to May 20, **not** logged as journal entries *but still in the same git repository*

**IN CLASS** means this was worked on in class

**AT HOME** means this was worked on outside of class

**BOTH** means this was worked on in class and continued outside, or vice versa

### May 20 **AT HOME** ~2 hours
Made a quick shotgun class to test out some of the features of the engine I was not as experienced with. I stole sprites from terraria :). This inital version was meant to be very messy. I first got the shotgun sprite to show up and point towards the cursor. Doing so did require adding support for rotations to the engine, which was not there before. I used the internet to find an applicable class, AffineTransform / AffineTransformOp, and then used the API plus what I learned recently in math class to define transformation functions to rotate and flip (about either axis) our images, and added an enum to sprite that contained some common rotation types such as NORMAL (any direction) BIDIRECTIONAL (the sprite shouldn't rotate, but should flip so that the x direction matches the direction), LOCKED (doesn't rotate), and UPRIGHT, which is a combination of NORMAL and BIDIRECTIONAL. Using this, I now made the character use this generalized system and I had a shotgun that appeared when fired it, and faced the cursor but was always upright (the trigger always pointed down somewhat down, regardless of the rotation). I made the shotgun fire bullets (these are literally just bodies but with initial velocity).

### May 21 **BOTH** ~3 hours
Originally I intended the shotgun to be something to play around with, but I realized a lot of our other items later on will have similar mechanics. I generalized most of the shotgun functionality as a UsetimeItem, which is just a sprite that is shown next to the parent but in the direction of the mouse when a key is pressed, has a cooldown, and does something during / on the action. This is heavily inspired by Terraria, which has similar characteristics for most of it's items. The math was kind of annoying (but not particularly hard) for some of this, but I got through it. We'll be able to use this for all sorts of things, such as weapons, melee weapons swings, consumables if we have any, and things like that. I then fixed an issue with the camera, which was that adding it to a node did not change it's functionality like it was supposed to. The camera should be centered at the parent node. I changed the engine to propogate a global position down in update for Node2D objects. An issue I encountered was that, when the camera was fixed the scene moved and worked perfectly, but when I used mouse input the mouseinput was not as expected. I diagnosed the problem as the mouse input giving screen coordinates but the usecases requiring local coordinates or global coordinates in the game coordinate system, not the screen. I just shifted the mouse input to be correct based on the camera's most recent global position. TODO: projectiles won't work with server and are kind of laggy since they never remove themselves. I did make them stop drawing after a set cooldown, so that helps with the lag but after like 1-3 minutes of firing a total of 9 bullets per second, the lag got noticably bad. Some optimizations we should do is that nodes that rotate shouldn't recalculate rotations if the rotation changed. I also implemented this, but it got lost in a merge conflict unfortunately. Restoring the previous implementation would be more work than reimplementing. Finally, I started my journal so I don't have to backfill like I did last year :p

### May 22 **AT HOME** ~2 hours
Continued with my divide and conquer of the demo shotgun: I make the previously created usetime sprite into a usetime event and added some other common nodes that usetime events should have, such as usetime sounds, sprites, and animations. I had to tweak animations a bit to distingush between repeating and non-repeating animations, repeating animations now just repeat endlessly while active, while non-repeating animations hide themselves when finished. There is currently a visual issue where the UPRIGHT rotation type applies to independent frames, but it's not noticable enough to be worth the effort to fix. My idea of usetime events is pretty much done, I don't really think it needs to be expanded on more; it's enough to display weapons and trigger events such as node creation for shooting projectiles.

### May 21 **IN CLASS** ~1 hour
Debugged the image util class. I had previously heavily relied on examples from documentation and therefore didn't understand the classes used as much as I had thought. This made it very hard to debug. The issue, which I had known would happen since I added rotation, was that images that weren't close to squares would have part of the image cut off because the transformation wasn't the same dimensions as the original image. I tried a bunch of fixes, but the key thing I missed was that transformation steps in affine transform were applied in reverse order. When I realized this (by looking at the api and through experimentation) I was able to fix rotations and make them rotate without clipping. I was feeling really sick on friday so I wasn't that productive in class and rested at home. I'm writing this on saturday and feel much better.

### MAY 28 **BOTH** ~2 hours
On another branch, I tried to get the multiplayer started up again to see how hard it would be to add it back (we had decided to remove it until the game is done and we're likely going to continue with that). The node reconcilation was a bit of a nightmare and the mutliplayer doesn't work, but I think that's just something we'll need to deal with later. I was unable to fix the issues.

### May 29 **AT HOME** ~1 hour
I added a basic enemy with contact damage that walks towards the player using the character system Qinzhao implemented. The enemy just deals contact damage to immortals, and it's velocity is calculated to be the heading to the nearest immortal times it's speed, as opposed to the input velocity vector times speed. On a less serious note I had my mom play my quick demo and she hated it because she's extremely bad at videogames, but once she got the hang of it she said it was fun. The current demo is extremely basic.

### June 1 **AT HOME** ~1.5 hours
I added health bars. This was fairly straightforwards, the calculations were easy but annoying. I did have to add functionality to render rectangles (we previously only had images), but this was just drawing onto a graphics object. I also spent some time debugging and improving the abilities. I made push be able to push multiple enemies, not attack the player, and the push lasts mutliple frames now. The way I did this was store a hashmap of all the enemies the push had intersected with and keep a tally of the number of frames remaining that they should be pushed for, and in the update cycle I made it push those enemies then reduce the tally. I didn't do this today, but forgot to mention it in my journal: I added an Uzi (type of machine gun) with it's own assets and firing style. Amendment: shortly after pushing I realized that my push ability code was prone to concurrent modification exceptions. I found a better way to update the tallies that did not have this problem, and also added sounds to the push ability with a short delay to sync the sound to the visuals.

### June 2 **AT HOME** ~5 hours
I did a lot of stuff today so I'm going to be fairly brief about each thing. First, I wanted to have fun and play around with adding some cool abilities.

I added a portal ability, and resprited / tweaked some of the existing abilities. The portal was a bit time-consuming to get right, but not too bad; my portals support 2 active portals and just teleport things between them with a cooldown while rotating them to match the rotational offset between the portals. This was later made useless as Qinzhao made the portals have locked rotation. I noticed that my portals ended up looking really cool when they started teleporting each other, so I made this an easter egg; It's pretty hard to start up, but if a portal is correctly placed next to another portal I made them 'merge' into a wider portal that locks enemies(and projectiles) in place until one of the portals is moved. This can be used by the player for cool stuff like instakilling enemies by locking them with bullets, and making 'bombs' that spray bullets everywhere.

Then I decided to increase enemy variety. I was heavily inspired by terraria's eater of worlds, and made my own in game. It is a 'congo line' of enemies, each one following the next and the head following the closest player. I also added spawners later in the day, which are just regular enemies that periodically have a spawn action, which is intended to be used to spawn things. They can move and fight on their own, but I decided to make them not do that for now as it would look weird with the current sprites.

I added level loading. The level format is a 3 integer header of the size of the blocks, the width (in blocks), and the height (in blocks), followed by a map of the level. Currently L is for java, lower case letters will be spawned enemies (e.g. y for a single wyrm), and upper case letters will be spawners for the relavent enemy (e.g. Y is a spawner that spawns wyrms). Someone removed easily snapping out of colliders and I didn't want to reimplement, so currently instead of walls we have lava! I feel like this will make things more interesting in the long run, and I also resprited things to be more like hell instead of a dungeon.

### June 3 **AT HOME** idk at least 4 hours
I resprited / found better assets for a lot of things. I made portals between levels that activate when all the enemies are destroyed, and modified the level format so that it specifies where the world's portals lead to, making it so that we can create levels just from the text files. After playtesting quite a lot, I decided to add visual indicators to show where far away portals and spawners are, I was able to reuse a lot of the math from abilties / usetime item. I also spent I lot of my time just designing the levels and rebalancing things to feel better to play. For example, I fixed Qinzhao's stun code to be better, and made the F ability have a lower cooldown and more for stunning rather than doing damage. I also fixed various bugs such as with the portals causing insane amounts of sound to be played.